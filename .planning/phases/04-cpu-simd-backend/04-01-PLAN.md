---
phase: 04-cpu-simd-backend
plan: 01
type: execute
depends_on: []
files_modified: [Cargo.toml, src/backend/mod.rs, src/backend/cpu_backend.rs]
autonomous: true
---

<objective>
Research and select SIMD strategy for CPU operations.

Purpose: Establish the foundation for optimized CPU fallback with SIMD acceleration
Output: Documented decision with crate selection and implementation approach
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/backend/mod.rs
@src/ggml/cpu_backend.rs
@src/tensor/matmul.rs
@src/attention/cpu.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Research Rust SIMD ecosystem</name>
  <files>Cargo.toml</files>
  <action>
    Research the following Rust SIMD options and document findings:

    **1. std::simd (nightly-only)**
    - Pros: Standard library, portable across architectures
    - Cons: Requires nightly Rust, unstable API, may break

    **2. packed_simd crate (portable_simd)**
    - Pros: Stable Rust, proposed for std, wide platform support (SSE/AVX/NEON)
    - Cons: External dependency, requires feature detection for optimal paths

    **3. wide crate**
    - Pros: Focus on portable SIMD, active development
    - Cons: Different API style, may not align with future std::simd

    **Key decision points:**
    - Target stability: need stable Rust for production
    - Platform support: AMD64 (Zen), x86_64 (AVX2), ARM64 (NEON)
    - Maintenance burden: external crates vs stdlib

    Research includes reading crate documentation, checking compilation status, and assessing API ergonomics.
  </action>
  <verify>Document findings in a summary</verify>
  <done>Research document created with crate comparison and recommendation</done>
</task>

<task type="auto">
  <name>Task 2: Select SIMD strategy and document decision</name>
  <files>src/backend/cpu_backend.rs, .planning/phases/04-cpu-simd-backend/DECISION.md</files>
  <action>
    Based on research, select the SIMD strategy and document in DECISION.md:

    **Recommendation:** Use `packed_simd` crate for portable SIMD.

    **Rationale:**
    - Stable Rust (no nightly required)
    - Proposed for std::simd (RFC 2366) - future-proof
    - Wide platform support (SSE/AVX2/NEON)
    - Ergonomic API: vertical/horizontal operations, masks, reductions
    - Strong community support

    **Implementation approach:**
    1. Add `packed_simd` as optional dependency in Cargo.toml
    2. Create CPU backend trait: `CpuBackend` with matmul, attention, softmax
    3. Implement matmul with packed_simd (f32x4 for 128-bit operations)
    4. Feature detection: detect SIMD support at runtime
    5. Fallback to scalar when SIMD unavailable

    Document:
    - Crate choice and rationale
    - Performance expectations
    - Feature detection strategy
  </action>
  <verify>DECISION.md created with SIMD strategy documented</verify>
  <done>Decision made and documented, ready for implementation plan</done>
</task>

</tasks>

<verification>
- [ ] Research document created in .planning/phases/04-cpu-simd-backend/RESEARCH.md
- [ ] DECISION.md created with SIMD strategy
- [ ] Cargo.toml updated with selected crate (if ready to add dependency)
</verification>

<success_criteria>

- SIMD crate selected and documented
- Implementation approach defined
- Feature detection strategy established
- Phase ready for 04-02 (CPU backend trait with SIMD matmul)
</success_criteria>

<output>
After completion, create `.planning/phases/04-cpu-simd-backend/04-01-SUMMARY.md`
</output>
