//! ROCm/HIP backend for GPU kernel execution

use std::ffi::{c_void, CStr, CString};
use std::ptr;
use thiserror::Error;

// HIP FFI bindings
#[link(name = "amdhip64")]
extern "C" {
    fn hipInit(flags: u32) -> i32;
    fn hipGetDeviceCount(count: *mut i32) -> i32;
    fn hipGetDeviceProperties(props: *mut HipDeviceProp, deviceId: i32) -> i32;
    fn hipSetDevice(deviceId: i32) -> i32;
    fn hipMalloc(ptr: *mut *mut c_void, size: usize) -> i32;
    fn hipFree(ptr: *mut c_void) -> i32;
    fn hipMemcpy(dst: *mut c_void, src: *const c_void, count: usize, kind: i32) -> i32;
    fn hipMemcpyHtoD(dst: *mut c_void, src: *const c_void, count: usize) -> i32;
    fn hipMemcpyDtoH(dst: *mut c_void, src: *const c_void, count: usize) -> i32;
    fn hipStreamCreate(stream: *mut *mut c_void) -> i32;
    fn hipStreamDestroy(stream: *mut c_void) -> i32;
    fn hipStreamSynchronize(stream: *mut c_void) -> i32;
    fn hipModuleLoad(module: *mut *mut c_void, path: *const i8) -> i32;
    fn hipModuleUnload(module: *mut c_void) -> i32;
    fn hipModuleGetFunction(func: *mut *mut c_void, module: *mut c_void, name: *const i8) -> i32;
    fn hipModuleLaunchKernel(
        func: *mut c_void,
        gridDimX: u32,
        gridDimY: u32,
        gridDimZ: u32,
        blockDimX: u32,
        blockDimY: u32,
        blockDimZ: u32,
        sharedMemBytes: u32,
        stream: *mut c_void,
        kernelParams: *mut *mut c_void,
        extra: *mut *mut c_void,
    ) -> i32;
    fn hipGetLastError() -> i32;
    fn hipGetErrorString(error: i32) -> *const i8;
    fn hipDeviceSynchronize() -> i32;
}

// HIP constants
const hipMemcpyHostToDevice: i32 = 1;
const hipMemcpyDeviceToHost: i32 = 2;
const hipSuccess: i32 = 0;

#[repr(C)]
#[derive(Debug, Clone)]
pub struct HipDeviceProp {
    pub name: [i8; 256],
    pub totalGlobalMem: usize,
    pub sharedMemPerBlock: usize,
    pub regsPerBlock: i32,
    pub warpSize: i32,
    pub maxThreadsPerBlock: i32,
    pub maxThreadsDim: [i32; 3],
    pub maxGridSize: [i32; 3],
    pub clockRate: i32,
    pub memoryClockRate: i32,
    pub memoryBusWidth: i32,
    pub totalConstMem: usize,
    pub major: i32,
    pub minor: i32,
    pub l2CacheSize: i32,
    pub maxThreadsPerMultiProcessor: i32,
    pub computeMode: i32,
    pub concurrentKernels: i32,
    pub pciDomainID: i32,
    pub pciBusID: i32,
    pub pciDeviceID: i32,
    pub maxSharedMemoryPerMultiProcessor: i32,
    pub isMultiGpuBoard: i32,
    pub canMapHostMemory: i32,
}

impl Default for HipDeviceProp {
    fn default() -> Self {
        HipDeviceProp {
            name: [0; 256],
            totalGlobalMem: 0,
            sharedMemPerBlock: 0,
            regsPerBlock: 0,
            warpSize: 32,
            maxThreadsPerBlock: 1024,
            maxThreadsDim: [1024, 1024, 64],
            maxGridSize: [2147483647, 65535, 65535],
            clockRate: 0,
            memoryClockRate: 0,
            memoryBusWidth: 0,
            totalConstMem: 0,
            major: 0,
            minor: 0,
            l2CacheSize: 0,
            maxThreadsPerMultiProcessor: 0,
            computeMode: 0,
            concurrentKernels: 0,
            pciDomainID: 0,
            pciBusID: 0,
            pciDeviceID: 0,
            maxSharedMemoryPerMultiProcessor: 0,
            isMultiGpuBoard: 0,
            canMapHostMemory: 0,
        }
    }
}

#[derive(Error, Debug)]
pub enum HipError {
    #[error("HIP initialization failed: {0}")]
    InitializationFailed(String),
    #[error("Kernel loading failed: {0}")]
    KernelLoadFailed(String),
    #[error("Memory allocation failed: {0}")]
    MemoryAllocationFailed(String),
    #[error("Memory copy failed: {0}")]
    MemoryCopyFailed(String),
    #[error("Kernel launch failed: {0}")]
    KernelLaunchFailed(String),
    #[error("Device not found")]
    DeviceNotFound,
    #[error("Device error: {0}")]
    DeviceError(String),
}

pub type HipResult<T> = Result<T, HipError>;

// SAFETY: HipStream is Send+Sync because it only contains a raw pointer
// and we ensure thread-safe access through proper synchronization
unsafe impl Send for HipStream {}
unsafe impl Sync for HipStream {}

#[derive(Debug, Clone)]
pub struct HipStream {
    stream: *mut c_void,
}

impl HipStream {
    pub fn new() -> HipResult<Self> {
        let mut stream: *mut c_void = ptr::null_mut();

        // Create HIP stream
        let result = unsafe { hipStreamCreate(&mut stream) };

        if result != hipSuccess {
            return Err(HipError::DeviceError(format!(
                "Failed to create HIP stream: {}",
                result
            )));
        }

        if stream.is_null() {
            return Err(HipError::DeviceError(
                "hipStreamCreate returned null pointer".to_string(),
            ));
        }

        Ok(HipStream { stream })
    }

    pub fn synchronize(&self) -> HipResult<()> {
        let result = unsafe { hipStreamSynchronize(self.stream) };
        if result != hipSuccess {
            Err(HipError::DeviceError(format!(
                "Stream synchronization failed: {}",
                result
            )))
        } else {
            Ok(())
        }
    }
}

impl Drop for HipStream {
    fn drop(&mut self) {
        if !self.stream.is_null() {
            unsafe {
                hipStreamDestroy(self.stream);
            }
        }
    }
}

// SAFETY: HipBuffer is Send+Sync because it only contains a raw pointer
// and we ensure thread-safe access through proper synchronization
unsafe impl Send for HipBuffer {}
unsafe impl Sync for HipBuffer {}

#[derive(Debug)]
pub struct HipBuffer {
    ptr: *mut c_void,
    pub size: usize,
}

impl HipBuffer {
    pub fn new(size: usize) -> HipResult<Self> {
        let mut ptr: *mut c_void = ptr::null_mut();

        // Use hipMalloc to allocate device memory
        let result = unsafe { hipMalloc(&mut ptr, size) };

        if result != hipSuccess {
            return Err(HipError::MemoryAllocationFailed(format!(
                "hipMalloc failed with code {} for {} bytes",
                result, size
            )));
        }

        if ptr.is_null() {
            return Err(HipError::MemoryAllocationFailed(format!(
                "hipMalloc returned null pointer for {} bytes",
                size
            )));
        }

        Ok(HipBuffer { ptr, size })
    }

    pub fn copy_from_host<T>(&self, data: &[T]) -> HipResult<()> {
        let byte_size = std::mem::size_of_val(data);
        if byte_size > self.size {
            return Err(HipError::MemoryAllocationFailed(format!(
                "Source data too large: {} > {}",
                byte_size, self.size
            )));
        }

        // Use hipMemcpyHtoD to copy from host to device
        let result = unsafe {
            hipMemcpy(
                self.ptr,
                data.as_ptr() as *const c_void,
                byte_size,
                hipMemcpyHostToDevice,
            )
        };

        if result != hipSuccess {
            return Err(HipError::MemoryCopyFailed(format!(
                "hipMemcpyHtoD failed with code {}",
                result
            )));
        }

        Ok(())
    }

    pub fn copy_to_host<T>(&self, data: &mut [T]) -> HipResult<()> {
        let byte_size = std::mem::size_of_val(data);
        if byte_size > self.size {
            return Err(HipError::MemoryAllocationFailed(format!(
                "Destination buffer too small: {} > {}",
                byte_size, self.size
            )));
        }

        // Use hipMemcpyDtoH to copy from device to host
        let result = unsafe {
            hipMemcpy(
                data.as_mut_ptr() as *mut c_void,
                self.ptr,
                byte_size,
                hipMemcpyDeviceToHost,
            )
        };

        if result != hipSuccess {
            return Err(HipError::MemoryCopyFailed(format!(
                "hipMemcpyDtoH failed with code {}",
                result
            )));
        }

        Ok(())
    }

    pub fn as_ptr(&self) -> *mut c_void {
        self.ptr
    }

    pub fn as_mut_ptr(&self) -> *mut c_void {
        self.ptr
    }

    pub fn size(&self) -> usize {
        self.size
    }
}

impl Drop for HipBuffer {
    fn drop(&mut self) {
        if !self.ptr.is_null() {
            // Use hipFree to free device memory
            unsafe {
                hipFree(self.ptr);
            }
        }
    }
}

// SAFETY: HipModule is Send+Sync because it only contains a raw pointer
// and we ensure thread-safe access through proper synchronization
unsafe impl Send for HipModule {}
unsafe impl Sync for HipModule {}

#[derive(Debug)]
pub struct HipModule {
    module: *mut c_void,
}

impl HipModule {
    pub fn from_ptr(module: *mut c_void) -> Self {
        HipModule { module }
    }

    pub fn as_ptr(&self) -> *mut c_void {
        self.module
    }
}

impl Drop for HipModule {
    fn drop(&mut self) {
        if !self.module.is_null() {
            unsafe {
                hipModuleUnload(self.module);
            }
        }
    }
}

// SAFETY: HipKernel is Send+Sync because it only contains a raw pointer
// and we ensure thread-safe access through proper synchronization
unsafe impl Send for HipKernel {}
unsafe impl Sync for HipKernel {}

#[derive(Debug)]
pub struct HipKernel {
    func: *mut c_void,
}

impl HipKernel {
    pub fn from_ptr(func: *mut c_void) -> Self {
        HipKernel { func }
    }

    pub fn as_ptr(&self) -> *mut c_void {
        self.func
    }
}

#[derive(Debug, Clone)]
pub struct HipDevice {
    pub device_id: i32,
    pub name: String,
    pub memory: usize,
    pub compute_units: i32,
}

#[derive(Debug, Clone)]
pub struct HipBackend {
    device: HipDevice,
    stream: HipStream,
}

impl HipBackend {
    pub fn new() -> HipResult<Self> {
        // Initialize HIP first
        Self::initialize_hip()?;

        // Detect AMD GPU
        let device = Self::detect_amd_gpu()?;

        // Create stream
        let stream = HipStream::new()?;

        Ok(HipBackend { device, stream })
    }

    fn detect_amd_gpu() -> HipResult<HipDevice> {
        let mut count: i32 = 0;
        let result = unsafe { hipGetDeviceCount(&mut count) };

        if result != hipSuccess {
            return Err(HipError::DeviceNotFound);
        }

        if count == 0 {
            return Err(HipError::DeviceNotFound);
        }

        // Get properties for first device
        let mut props = HipDeviceProp::default();
        let result = unsafe { hipGetDeviceProperties(&mut props, 0) };

        if result != hipSuccess {
            return Err(HipError::DeviceError(format!(
                "Failed to get device properties: {}",
                result
            )));
        }

        let device_name = unsafe {
            std::ffi::CStr::from_ptr(props.name.as_ptr())
                .to_string_lossy()
                .into_owned()
        };

        Ok(HipDevice {
            device_id: 0,
            name: device_name,
            memory: props.totalGlobalMem,
            compute_units: props.maxThreadsPerMultiProcessor,
        })
    }

        if count == 0 {
            return Err(HipError::DeviceNotFound);
        }

        // Get properties for first device
        let mut props = HipDeviceProp::default();
        let result = unsafe { hipGetDeviceProperties(&mut props, 0) };

        if result != hipSuccess {
            return Err(HipError::DeviceError(format!(
                "Failed to get device properties: {}",
                result
            )));
        }

        let device_name = unsafe {
            std::ffi::CStr::from_ptr(props.name.as_ptr())
                .to_string_lossy()
                .into_owned()
        };

        Ok(HipDevice {
            device_id: 0,
            name: device_name,
            memory: props.totalGlobalMem,
            compute_units: props.maxThreadsPerMultiProcessor,
        })
    }

        if count == 0 {
            return Err(HipError::DeviceNotFound);
        }

        // Get properties for first device
        let mut props = HipDeviceProp::default();
        let result = unsafe { hipGetDeviceProperties(&mut props, 0) };

        if result != hipSuccess {
            return Err(HipError::DeviceError(format!(
                "Failed to get device properties: {}",
                result
            )));
        }

        let device_name = unsafe {
            std::ffi::CStr::from_ptr(props.name.as_ptr())
                .to_string_lossy()
                .into_owned()
        };

        Ok(HipDevice {
            device_id: 0,
            name: device_name,
            memory: props.totalGlobalMem,
            compute_units: props.maxThreadsPerMultiProcessor,
        })
    }

        if count == 0 {
            println!("DEBUG: No devices found");
            return Err(HipError::DeviceNotFound);
        }

        println!("DEBUG: About to get device properties");
        // Get properties for first device
        let mut props = HipDeviceProp::default();
        let result = unsafe { hipGetDeviceProperties(&mut props, 0) };
        println!("DEBUG: hipGetDeviceProperties result: {}", result);

        if result != hipSuccess {
            println!("DEBUG: hipGetDeviceProperties failed");
            return Err(HipError::DeviceError(format!(
                "Failed to get device properties: {}",
                result
            )));
        }

        println!("DEBUG: About to convert device name");
        let device_name = unsafe {
            std::ffi::CStr::from_ptr(props.name.as_ptr())
                .to_string_lossy()
                .into_owned()
        };
        println!("DEBUG: Device name: {}", device_name);

        println!("DEBUG: About to create HipDevice");
        Ok(HipDevice {
            device_id: 0,
            name: device_name,
            memory: props.totalGlobalMem,
            compute_units: props.maxThreadsPerMultiProcessor,
        })
    }

    fn initialize_hip() -> HipResult<()> {
        let result = unsafe { hipInit(0) };

        if result != hipSuccess {
            return Err(HipError::InitializationFailed(format!(
                "hipInit failed with code {}",
                result
            )));
        }

        Ok(())
    }

    pub fn device(&self) -> &HipDevice {
        &self.device
    }

    pub fn stream(&self) -> &HipStream {
        &self.stream
    }

    pub fn allocate_buffer(&self, size: usize) -> HipResult<HipBuffer> {
        HipBuffer::new(size)
    }

    pub fn launch_kernel(
        &self,
        kernel_name: &str,
        grid_dim: (u32, u32, u32),
        block_dim: (u32, u32, u32),
        args: &[*mut c_void],
    ) -> HipResult<()> {
        // In a real implementation, this would:
        // 1. Load the compiled kernel module
        // 2. Get the kernel function pointer
        // 3. Launch the kernel with hipModuleLaunchKernel

        println!(
            "Launching kernel '{}' with grid {:?} and block {:?}",
            kernel_name, grid_dim, block_dim
        );

        Ok(())
    }

    pub fn synchronize(&self) -> HipResult<()> {
        self.stream.synchronize()
    }

    // Methods needed for smoke tests
    pub fn load_module(&self, path: &str) -> HipResult<HipModule> {
        let path_cstr = CString::new(path)
            .map_err(|e| HipError::KernelLoadFailed(format!("Invalid path string: {}", e)))?;

        let mut module: *mut c_void = ptr::null_mut();
        let result = unsafe { hipModuleLoad(&mut module, path_cstr.as_ptr()) };

        if result != hipSuccess {
            let error_msg = unsafe {
                let error_ptr = hipGetErrorString(result);
                if error_ptr.is_null() {
                    "Unknown error".to_string()
                } else {
                    std::ffi::CStr::from_ptr(error_ptr)
                        .to_string_lossy()
                        .into_owned()
                }
            };
            return Err(HipError::KernelLoadFailed(format!(
                "Failed to load module '{}': {}",
                path, error_msg
            )));
        }

        Ok(HipModule::from_ptr(module))
    }

    pub fn get_kernel(&self, module_path: &str, kernel_name: &str) -> HipResult<HipKernel> {
        // Load the module
        let module = self.load_module(module_path)?;

        // Get the kernel function from the module
        self.get_kernel_function(&module, kernel_name)
    }

    /// Get kernel function from a loaded module
    pub fn get_kernel_function(
        &self,
        module: &HipModule,
        kernel_name: &str,
    ) -> HipResult<HipKernel> {
        let kernel_name_cstr = CString::new(kernel_name)
            .map_err(|e| HipError::KernelLoadFailed(format!("Invalid kernel name: {}", e)))?;

        let mut func: *mut c_void = ptr::null_mut();
        let result =
            unsafe { hipModuleGetFunction(&mut func, module.as_ptr(), kernel_name_cstr.as_ptr()) };

        if result != hipSuccess {
            let error_msg = unsafe {
                let error_ptr = hipGetErrorString(result);
                if error_ptr.is_null() {
                    "Unknown error".to_string()
                } else {
                    std::ffi::CStr::from_ptr(error_ptr)
                        .to_string_lossy()
                        .into_owned()
                }
            };
            return Err(HipError::KernelLoadFailed(format!(
                "Failed to get kernel '{}': {}",
                kernel_name, error_msg
            )));
        }

        Ok(HipKernel::from_ptr(func))
    }

    /// Get the number of available HIP devices
    pub fn get_device_count(&self) -> HipResult<i32> {
        let mut count: i32 = 0;
        let result = unsafe { hipGetDeviceCount(&mut count) };

        if result != hipSuccess {
            let error_msg = unsafe {
                let error_ptr = hipGetErrorString(result);
                if error_ptr.is_null() {
                    "Unknown error".to_string()
                } else {
                    std::ffi::CStr::from_ptr(error_ptr)
                        .to_string_lossy()
                        .into_owned()
                }
            };
            return Err(HipError::DeviceError(format!(
                "Failed to get device count: {}",
                error_msg
            )));
        }

        Ok(count)
    }

    /// Get properties for a specific HIP device
    pub fn get_device_properties(&self, device_id: i32) -> HipResult<HipDeviceProp> {
        let mut props = HipDeviceProp::default();
        let result = unsafe { hipGetDeviceProperties(&mut props, device_id) };

        if result != hipSuccess {
            let error_msg = unsafe {
                let error_ptr = hipGetErrorString(result);
                if error_ptr.is_null() {
                    "Unknown error".to_string()
                } else {
                    std::ffi::CStr::from_ptr(error_ptr)
                        .to_string_lossy()
                        .into_owned()
                }
            };
            return Err(HipError::DeviceError(format!(
                "Failed to get device properties: {}",
                error_msg
            )));
        }

        Ok(props)
    }

    pub fn alloc_gpu_buffer<T>(&self, len: usize) -> HipResult<HipBuffer> {
        let size = len * std::mem::size_of::<T>();
        self.allocate_buffer(size)
    }

    pub fn copy_to_gpu<T>(&self, host_data: &[T], gpu_buffer: &HipBuffer) -> HipResult<()> {
        gpu_buffer.copy_from_host(host_data)
    }

    pub fn copy_from_gpu<T>(&self, gpu_buffer: &HipBuffer, host_data: &mut [T]) -> HipResult<()> {
        gpu_buffer.copy_to_host(host_data)
    }

    pub fn launch_kernel_with_module(
        &self,
        kernel: &HipKernel,
        grid_dim: (u32, u32, u32),
        block_dim: (u32, u32, u32),
        args: &[*mut c_void],
    ) -> HipResult<()> {
        let result = unsafe {
            hipModuleLaunchKernel(
                kernel.as_ptr(),
                grid_dim.0,
                grid_dim.1,
                grid_dim.2,
                block_dim.0,
                block_dim.1,
                block_dim.2,
                0, // sharedMemBytes
                self.stream.stream,
                args.as_ptr() as *mut *mut c_void,
                ptr::null_mut(), // extra
            )
        };

        if result != hipSuccess {
            let error_msg = unsafe {
                let error_ptr = hipGetErrorString(result);
                if error_ptr.is_null() {
                    "Unknown error".to_string()
                } else {
                    std::ffi::CStr::from_ptr(error_ptr)
                        .to_string_lossy()
                        .into_owned()
                }
            };
            return Err(HipError::KernelLaunchFailed(format!(
                "Kernel launch failed: {}",
                error_msg
            )));
        }

        Ok(())
    }

    /// Get softmax kernel function pointer
    pub fn get_softmax_kernel(&self) -> HipResult<HipKernel> {
        // Load the softmax module and get the kernel function
        let module = self.load_module("kernels/softmax.hip")?;
        self.get_kernel_function(&module, "softmax_kernel")
    }

    /// Get mask kernel function pointer  
    pub fn get_mask_kernel(&self) -> HipResult<HipKernel> {
        // Load the mask module and get the kernel function
        let module = self.load_module("kernels/mask.hip")?;
        self.get_kernel_function(&module, "mask_kernel")
    }

    /// Get scale kernel function pointer
    pub fn get_scale_kernel(&self) -> HipResult<HipKernel> {
        // Load the scale module and get the kernel function
        let module = self.load_module("kernels/scale.hip")?;
        self.get_kernel_function(&module, "scale_kernel")
    }
}

/// Module-level device synchronization function
pub fn synchronize_device() -> HipResult<()> {
    let result = unsafe { hipDeviceSynchronize() };

    if result != hipSuccess {
        return Err(HipError::DeviceError(format!(
            "Device synchronization failed: {}",
            result
        )));
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hip_backend_creation() {
        let backend = HipBackend::new();
        assert!(backend.is_ok());

        let backend = backend.unwrap();
        assert_eq!(backend.device().device_id, 0);
        assert!(!backend.device().name.is_empty());
    }

    #[test]
    fn test_buffer_allocation() {
        let backend = HipBackend::new().unwrap();
        let buffer = backend.allocate_buffer(1024);
        assert!(buffer.is_ok());

        let buffer = buffer.unwrap();
        assert_eq!(buffer.size(), 1024);
    }

    #[test]
    fn test_buffer_copy() {
        let backend = HipBackend::new().unwrap();
        let buffer = backend
            .allocate_buffer(4 * std::mem::size_of::<f32>())
            .unwrap();

        let host_data = [1.0f32, 2.0, 3.0, 4.0];
        assert!(buffer.copy_from_host(&host_data).is_ok());

        let mut host_result = [0.0f32; 4];
        assert!(buffer.copy_to_host(&mut host_result).is_ok());

        assert_eq!(host_data, host_result);
    }

    #[test]
    fn test_kernel_launch() {
        let backend = HipBackend::new().unwrap();
        let args: Vec<*mut c_void> = vec![];

        let result = backend.launch_kernel("test_kernel", (1, 1, 1), (64, 1, 1), &args);

        assert!(result.is_ok());
    }
}
